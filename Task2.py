first = input('The first word: ')
second = input('The second word: ')

def howFar(x,y):
    theX = len(x)
    theY = len(y)

    # длина первого эл-та д.б. меньше или равной длине второго
    # поэтому если это не так - меняем местами строки
    # перед проведением сравнения
    if theX > theY:
        x, y = y, x
        theX, theY = theY, theX

    # работа будет вестись построчно, а не в матрице
    # - т.к., в принципе, при просмотре каждого эл-та матрицы
    # мы смотрим на эл-те слева, сверху и слева-сверху,
    # так что вся матрица сразу нам и не нужна
    activeLine = range(theX+1)

    print(activeLine)

    # почему такой промежуток?
    # не от 0 - т.к. матрица от 1 до theY | theX
    # зачем во втором параметре +1:
    # потому что верхняя обозначенная граница не включается в отрезок
    # - т.е. чтобы не потерять theY | theX
    for i in range(1, theY+1):

        # тут, рассмотрев строку,
        # мы переходим к рассмотрению следующей,
        # посему предыдущая (только что рассмотренная)
        # уходит в эту переменную для дальнейшей работы
        previousLine = activeLine

        # новую строку (еще не рассмотренную,
        # но к рассмотрению которой мы приступаем) мы заполняем i и нулями:
        # потребуется массив из числа i и theX нулей
        activeLine = [i] + [0] * theX

        for j in range(1, theX+1):
            addSymbol = previousLine[j]+1
            deleteSymbol =activeLine[j-1]+1
            changeSymbol =previousLine[j-1]

            # почему рассматриваем элемент *-1?
            # - потому, что по матрице (отсчет от 1) у него один индекс,
            # а по строке (прогр., отсчет от 0) - другой
            if x[j-1] != y[i-1]:

                # почему мы не описываем, при каких условиях
                # срабатывают addSymbol и deleteSymbol?
                # - потому, что мы в любом случае их проворачиваем
                changeSymbol += 1


            # вот тут он откуда вообще знает, что и почему делать?
            # - он тут выбирает минимальное расстояние на основе того,
            # что знает: сейчас у него три пути действий,
            # расстояние для которых известно,
            # и из этого просто надо выбрать минимум
            activeLine[j] = min(addSymbol, deleteSymbol, changeSymbol)

    return activeLine[theX]


print(howFar(first, second))
